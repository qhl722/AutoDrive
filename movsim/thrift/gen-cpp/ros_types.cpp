/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "ros_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace Ros {


GridMap::~GridMap() throw() {
}


void GridMap::__set_width(const int32_t val) {
  this->width = val;
}

void GridMap::__set_length(const int32_t val) {
  this->length = val;
}

void GridMap::__set_center_x(const int32_t val) {
  this->center_x = val;
}

void GridMap::__set_center_y(const int32_t val) {
  this->center_y = val;
}

void GridMap::__set_grid_map(const std::vector<int16_t> & val) {
  this->grid_map = val;
}

uint32_t GridMap::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->width);
          this->__isset.width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->length);
          this->__isset.length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->center_x);
          this->__isset.center_x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->center_y);
          this->__isset.center_y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->grid_map.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->grid_map.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readI16(this->grid_map[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.grid_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GridMap::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GridMap");

  xfer += oprot->writeFieldBegin("width", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->width);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("length", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->length);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("center_x", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->center_x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("center_y", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->center_y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("grid_map", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->grid_map.size()));
    std::vector<int16_t> ::const_iterator _iter5;
    for (_iter5 = this->grid_map.begin(); _iter5 != this->grid_map.end(); ++_iter5)
    {
      xfer += oprot->writeI16((*_iter5));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GridMap &a, GridMap &b) {
  using ::std::swap;
  swap(a.width, b.width);
  swap(a.length, b.length);
  swap(a.center_x, b.center_x);
  swap(a.center_y, b.center_y);
  swap(a.grid_map, b.grid_map);
  swap(a.__isset, b.__isset);
}

GridMap::GridMap(const GridMap& other6) {
  width = other6.width;
  length = other6.length;
  center_x = other6.center_x;
  center_y = other6.center_y;
  grid_map = other6.grid_map;
  __isset = other6.__isset;
}
GridMap& GridMap::operator=(const GridMap& other7) {
  width = other7.width;
  length = other7.length;
  center_x = other7.center_x;
  center_y = other7.center_y;
  grid_map = other7.grid_map;
  __isset = other7.__isset;
  return *this;
}
void GridMap::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GridMap(";
  out << "width=" << to_string(width);
  out << ", " << "length=" << to_string(length);
  out << ", " << "center_x=" << to_string(center_x);
  out << ", " << "center_y=" << to_string(center_y);
  out << ", " << "grid_map=" << to_string(grid_map);
  out << ")";
}


WayPoint::~WayPoint() throw() {
}


void WayPoint::__set_x(const double val) {
  this->x = val;
}

void WayPoint::__set_y(const double val) {
  this->y = val;
}

uint32_t WayPoint::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t WayPoint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("WayPoint");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(WayPoint &a, WayPoint &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.__isset, b.__isset);
}

WayPoint::WayPoint(const WayPoint& other8) {
  x = other8.x;
  y = other8.y;
  __isset = other8.__isset;
}
WayPoint& WayPoint::operator=(const WayPoint& other9) {
  x = other9.x;
  y = other9.y;
  __isset = other9.__isset;
  return *this;
}
void WayPoint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "WayPoint(";
  out << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ")";
}


LaneMarker::~LaneMarker() throw() {
}


void LaneMarker::__set_paint_type(const int16_t val) {
  this->paint_type = val;
}

void LaneMarker::__set_waypoints(const std::vector<WayPoint> & val) {
  this->waypoints = val;
}

uint32_t LaneMarker::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->paint_type);
          this->__isset.paint_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->waypoints.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->waypoints.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += this->waypoints[_i14].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.waypoints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LaneMarker::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LaneMarker");

  xfer += oprot->writeFieldBegin("paint_type", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->paint_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("waypoints", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->waypoints.size()));
    std::vector<WayPoint> ::const_iterator _iter15;
    for (_iter15 = this->waypoints.begin(); _iter15 != this->waypoints.end(); ++_iter15)
    {
      xfer += (*_iter15).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LaneMarker &a, LaneMarker &b) {
  using ::std::swap;
  swap(a.paint_type, b.paint_type);
  swap(a.waypoints, b.waypoints);
  swap(a.__isset, b.__isset);
}

LaneMarker::LaneMarker(const LaneMarker& other16) {
  paint_type = other16.paint_type;
  waypoints = other16.waypoints;
  __isset = other16.__isset;
}
LaneMarker& LaneMarker::operator=(const LaneMarker& other17) {
  paint_type = other17.paint_type;
  waypoints = other17.waypoints;
  __isset = other17.__isset;
  return *this;
}
void LaneMarker::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LaneMarker(";
  out << "paint_type=" << to_string(paint_type);
  out << ", " << "waypoints=" << to_string(waypoints);
  out << ")";
}


SectionList::~SectionList() throw() {
}


void SectionList::__set_lane_marker_list(const std::vector<LaneMarker> & val) {
  this->lane_marker_list = val;
}

void SectionList::__set_section_type(const int16_t val) {
  this->section_type = val;
}

uint32_t SectionList::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->lane_marker_list.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _etype21;
            xfer += iprot->readListBegin(_etype21, _size18);
            this->lane_marker_list.resize(_size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              xfer += this->lane_marker_list[_i22].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.lane_marker_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->section_type);
          this->__isset.section_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SectionList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SectionList");

  xfer += oprot->writeFieldBegin("lane_marker_list", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->lane_marker_list.size()));
    std::vector<LaneMarker> ::const_iterator _iter23;
    for (_iter23 = this->lane_marker_list.begin(); _iter23 != this->lane_marker_list.end(); ++_iter23)
    {
      xfer += (*_iter23).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("section_type", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->section_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SectionList &a, SectionList &b) {
  using ::std::swap;
  swap(a.lane_marker_list, b.lane_marker_list);
  swap(a.section_type, b.section_type);
  swap(a.__isset, b.__isset);
}

SectionList::SectionList(const SectionList& other24) {
  lane_marker_list = other24.lane_marker_list;
  section_type = other24.section_type;
  __isset = other24.__isset;
}
SectionList& SectionList::operator=(const SectionList& other25) {
  lane_marker_list = other25.lane_marker_list;
  section_type = other25.section_type;
  __isset = other25.__isset;
  return *this;
}
void SectionList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SectionList(";
  out << "lane_marker_list=" << to_string(lane_marker_list);
  out << ", " << "section_type=" << to_string(section_type);
  out << ")";
}


DynamicObstacle::~DynamicObstacle() throw() {
}


void DynamicObstacle::__set_class_id(const int16_t val) {
  this->class_id = val;
}

void DynamicObstacle::__set_id(const int64_t val) {
  this->id = val;
}

void DynamicObstacle::__set_center_x(const double val) {
  this->center_x = val;
}

void DynamicObstacle::__set_center_y(const double val) {
  this->center_y = val;
}

void DynamicObstacle::__set_center_z(const double val) {
  this->center_z = val;
}

void DynamicObstacle::__set_width(const double val) {
  this->width = val;
}

void DynamicObstacle::__set_height(const double val) {
  this->height = val;
}

void DynamicObstacle::__set_length(const double val) {
  this->length = val;
}

void DynamicObstacle::__set_velocity(const double val) {
  this->velocity = val;
}

void DynamicObstacle::__set_heading(const double val) {
  this->heading = val;
}

void DynamicObstacle::__set_omega(const double val) {
  this->omega = val;
}

void DynamicObstacle::__set_acceleration(const double val) {
  this->acceleration = val;
}

void DynamicObstacle::__set_shield_time(const double val) {
  this->shield_time = val;
}

void DynamicObstacle::__set_velocity_measurement_covariance(const std::vector<double> & val) {
  this->velocity_measurement_covariance = val;
}

uint32_t DynamicObstacle::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->class_id);
          this->__isset.class_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->center_x);
          this->__isset.center_x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->center_y);
          this->__isset.center_y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->center_z);
          this->__isset.center_z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->width);
          this->__isset.width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->height);
          this->__isset.height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->length);
          this->__isset.length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->velocity);
          this->__isset.velocity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->heading);
          this->__isset.heading = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->omega);
          this->__isset.omega = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->acceleration);
          this->__isset.acceleration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->shield_time);
          this->__isset.shield_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->velocity_measurement_covariance.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->velocity_measurement_covariance.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += iprot->readDouble(this->velocity_measurement_covariance[_i30]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.velocity_measurement_covariance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DynamicObstacle::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DynamicObstacle");

  xfer += oprot->writeFieldBegin("class_id", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->class_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("center_x", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->center_x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("center_y", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->center_y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("center_z", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->center_z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("width", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->width);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("height", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("length", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->length);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("velocity", ::apache::thrift::protocol::T_DOUBLE, 9);
  xfer += oprot->writeDouble(this->velocity);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("heading", ::apache::thrift::protocol::T_DOUBLE, 10);
  xfer += oprot->writeDouble(this->heading);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("omega", ::apache::thrift::protocol::T_DOUBLE, 11);
  xfer += oprot->writeDouble(this->omega);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acceleration", ::apache::thrift::protocol::T_DOUBLE, 12);
  xfer += oprot->writeDouble(this->acceleration);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shield_time", ::apache::thrift::protocol::T_DOUBLE, 13);
  xfer += oprot->writeDouble(this->shield_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("velocity_measurement_covariance", ::apache::thrift::protocol::T_LIST, 14);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->velocity_measurement_covariance.size()));
    std::vector<double> ::const_iterator _iter31;
    for (_iter31 = this->velocity_measurement_covariance.begin(); _iter31 != this->velocity_measurement_covariance.end(); ++_iter31)
    {
      xfer += oprot->writeDouble((*_iter31));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DynamicObstacle &a, DynamicObstacle &b) {
  using ::std::swap;
  swap(a.class_id, b.class_id);
  swap(a.id, b.id);
  swap(a.center_x, b.center_x);
  swap(a.center_y, b.center_y);
  swap(a.center_z, b.center_z);
  swap(a.width, b.width);
  swap(a.height, b.height);
  swap(a.length, b.length);
  swap(a.velocity, b.velocity);
  swap(a.heading, b.heading);
  swap(a.omega, b.omega);
  swap(a.acceleration, b.acceleration);
  swap(a.shield_time, b.shield_time);
  swap(a.velocity_measurement_covariance, b.velocity_measurement_covariance);
  swap(a.__isset, b.__isset);
}

DynamicObstacle::DynamicObstacle(const DynamicObstacle& other32) {
  class_id = other32.class_id;
  id = other32.id;
  center_x = other32.center_x;
  center_y = other32.center_y;
  center_z = other32.center_z;
  width = other32.width;
  height = other32.height;
  length = other32.length;
  velocity = other32.velocity;
  heading = other32.heading;
  omega = other32.omega;
  acceleration = other32.acceleration;
  shield_time = other32.shield_time;
  velocity_measurement_covariance = other32.velocity_measurement_covariance;
  __isset = other32.__isset;
}
DynamicObstacle& DynamicObstacle::operator=(const DynamicObstacle& other33) {
  class_id = other33.class_id;
  id = other33.id;
  center_x = other33.center_x;
  center_y = other33.center_y;
  center_z = other33.center_z;
  width = other33.width;
  height = other33.height;
  length = other33.length;
  velocity = other33.velocity;
  heading = other33.heading;
  omega = other33.omega;
  acceleration = other33.acceleration;
  shield_time = other33.shield_time;
  velocity_measurement_covariance = other33.velocity_measurement_covariance;
  __isset = other33.__isset;
  return *this;
}
void DynamicObstacle::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DynamicObstacle(";
  out << "class_id=" << to_string(class_id);
  out << ", " << "id=" << to_string(id);
  out << ", " << "center_x=" << to_string(center_x);
  out << ", " << "center_y=" << to_string(center_y);
  out << ", " << "center_z=" << to_string(center_z);
  out << ", " << "width=" << to_string(width);
  out << ", " << "height=" << to_string(height);
  out << ", " << "length=" << to_string(length);
  out << ", " << "velocity=" << to_string(velocity);
  out << ", " << "heading=" << to_string(heading);
  out << ", " << "omega=" << to_string(omega);
  out << ", " << "acceleration=" << to_string(acceleration);
  out << ", " << "shield_time=" << to_string(shield_time);
  out << ", " << "velocity_measurement_covariance=" << to_string(velocity_measurement_covariance);
  out << ")";
}


TrafficLight::~TrafficLight() throw() {
}


void TrafficLight::__set_id(const int16_t val) {
  this->id = val;
}

void TrafficLight::__set_type(const int16_t val) {
  this->type = val;
}

void TrafficLight::__set_status(const int16_t val) {
  this->status = val;
}

void TrafficLight::__set_time(const int16_t val) {
  this->time = val;
}

void TrafficLight::__set_confidence(const double val) {
  this->confidence = val;
}

uint32_t TrafficLight::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->confidence);
          this->__isset.confidence = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TrafficLight::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TrafficLight");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("confidence", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->confidence);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TrafficLight &a, TrafficLight &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.type, b.type);
  swap(a.status, b.status);
  swap(a.time, b.time);
  swap(a.confidence, b.confidence);
  swap(a.__isset, b.__isset);
}

TrafficLight::TrafficLight(const TrafficLight& other34) {
  id = other34.id;
  type = other34.type;
  status = other34.status;
  time = other34.time;
  confidence = other34.confidence;
  __isset = other34.__isset;
}
TrafficLight& TrafficLight::operator=(const TrafficLight& other35) {
  id = other35.id;
  type = other35.type;
  status = other35.status;
  time = other35.time;
  confidence = other35.confidence;
  __isset = other35.__isset;
  return *this;
}
void TrafficLight::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TrafficLight(";
  out << "id=" << to_string(id);
  out << ", " << "type=" << to_string(type);
  out << ", " << "status=" << to_string(status);
  out << ", " << "time=" << to_string(time);
  out << ", " << "confidence=" << to_string(confidence);
  out << ")";
}


TrafficLightDetect::~TrafficLightDetect() throw() {
}


void TrafficLightDetect::__set_timestamp(const int64_t val) {
  this->timestamp = val;
}

void TrafficLightDetect::__set_tl_det_list(const std::vector<TrafficLight> & val) {
  this->tl_det_list = val;
}

uint32_t TrafficLightDetect::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tl_det_list.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->tl_det_list.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += this->tl_det_list[_i40].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tl_det_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TrafficLightDetect::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TrafficLightDetect");

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tl_det_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tl_det_list.size()));
    std::vector<TrafficLight> ::const_iterator _iter41;
    for (_iter41 = this->tl_det_list.begin(); _iter41 != this->tl_det_list.end(); ++_iter41)
    {
      xfer += (*_iter41).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TrafficLightDetect &a, TrafficLightDetect &b) {
  using ::std::swap;
  swap(a.timestamp, b.timestamp);
  swap(a.tl_det_list, b.tl_det_list);
  swap(a.__isset, b.__isset);
}

TrafficLightDetect::TrafficLightDetect(const TrafficLightDetect& other42) {
  timestamp = other42.timestamp;
  tl_det_list = other42.tl_det_list;
  __isset = other42.__isset;
}
TrafficLightDetect& TrafficLightDetect::operator=(const TrafficLightDetect& other43) {
  timestamp = other43.timestamp;
  tl_det_list = other43.tl_det_list;
  __isset = other43.__isset;
  return *this;
}
void TrafficLightDetect::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TrafficLightDetect(";
  out << "timestamp=" << to_string(timestamp);
  out << ", " << "tl_det_list=" << to_string(tl_det_list);
  out << ")";
}


Localize::~Localize() throw() {
}


void Localize::__set_timestamp(const int64_t val) {
  this->timestamp = val;
}

void Localize::__set_raw_data(const std::string& val) {
  this->raw_data = val;
}

void Localize::__set_mTime(const double val) {
  this->mTime = val;
}

void Localize::__set_latitude(const double val) {
  this->latitude = val;
}

void Localize::__set_longitude(const double val) {
  this->longitude = val;
}

void Localize::__set_altitude(const double val) {
  this->altitude = val;
}

void Localize::__set_vel_x(const double val) {
  this->vel_x = val;
}

void Localize::__set_vel_y(const double val) {
  this->vel_y = val;
}

void Localize::__set_vel_z(const double val) {
  this->vel_z = val;
}

void Localize::__set_acc_x(const double val) {
  this->acc_x = val;
}

void Localize::__set_acc_y(const double val) {
  this->acc_y = val;
}

void Localize::__set_acc_z(const double val) {
  this->acc_z = val;
}

void Localize::__set_nav_mode(const int16_t val) {
  this->nav_mode = val;
}

void Localize::__set_pos_mode(const int16_t val) {
  this->pos_mode = val;
}

void Localize::__set_vel_mode(const int16_t val) {
  this->vel_mode = val;
}

void Localize::__set_att_mode(const int16_t val) {
  this->att_mode = val;
}

void Localize::__set_angular_vel_x(const double val) {
  this->angular_vel_x = val;
}

void Localize::__set_angular_vel_y(const double val) {
  this->angular_vel_y = val;
}

void Localize::__set_angular_vel_z(const double val) {
  this->angular_vel_z = val;
}

void Localize::__set_heading(const double val) {
  this->heading = val;
}

void Localize::__set_pitch(const double val) {
  this->pitch = val;
}

void Localize::__set_roll(const double val) {
  this->roll = val;
}

void Localize::__set_pose_x(const double val) {
  this->pose_x = val;
}

void Localize::__set_pose_y(const double val) {
  this->pose_y = val;
}

uint32_t Localize::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->raw_data);
          this->__isset.raw_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->mTime);
          this->__isset.mTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->latitude);
          this->__isset.latitude = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->longitude);
          this->__isset.longitude = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->altitude);
          this->__isset.altitude = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->vel_x);
          this->__isset.vel_x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->vel_y);
          this->__isset.vel_y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->vel_z);
          this->__isset.vel_z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->acc_x);
          this->__isset.acc_x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->acc_y);
          this->__isset.acc_y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->acc_z);
          this->__isset.acc_z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->nav_mode);
          this->__isset.nav_mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->pos_mode);
          this->__isset.pos_mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->vel_mode);
          this->__isset.vel_mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->att_mode);
          this->__isset.att_mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->angular_vel_x);
          this->__isset.angular_vel_x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->angular_vel_y);
          this->__isset.angular_vel_y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->angular_vel_z);
          this->__isset.angular_vel_z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->heading);
          this->__isset.heading = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->pitch);
          this->__isset.pitch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->roll);
          this->__isset.roll = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->pose_x);
          this->__isset.pose_x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->pose_y);
          this->__isset.pose_y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Localize::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Localize");

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("raw_data", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->raw_data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mTime", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->mTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("latitude", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->latitude);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("longitude", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->longitude);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("altitude", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->altitude);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vel_x", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->vel_x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vel_y", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->vel_y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vel_z", ::apache::thrift::protocol::T_DOUBLE, 9);
  xfer += oprot->writeDouble(this->vel_z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acc_x", ::apache::thrift::protocol::T_DOUBLE, 10);
  xfer += oprot->writeDouble(this->acc_x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acc_y", ::apache::thrift::protocol::T_DOUBLE, 11);
  xfer += oprot->writeDouble(this->acc_y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acc_z", ::apache::thrift::protocol::T_DOUBLE, 12);
  xfer += oprot->writeDouble(this->acc_z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nav_mode", ::apache::thrift::protocol::T_I16, 13);
  xfer += oprot->writeI16(this->nav_mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pos_mode", ::apache::thrift::protocol::T_I16, 14);
  xfer += oprot->writeI16(this->pos_mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("vel_mode", ::apache::thrift::protocol::T_I16, 15);
  xfer += oprot->writeI16(this->vel_mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("att_mode", ::apache::thrift::protocol::T_I16, 16);
  xfer += oprot->writeI16(this->att_mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("angular_vel_x", ::apache::thrift::protocol::T_DOUBLE, 17);
  xfer += oprot->writeDouble(this->angular_vel_x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("angular_vel_y", ::apache::thrift::protocol::T_DOUBLE, 18);
  xfer += oprot->writeDouble(this->angular_vel_y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("angular_vel_z", ::apache::thrift::protocol::T_DOUBLE, 19);
  xfer += oprot->writeDouble(this->angular_vel_z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("heading", ::apache::thrift::protocol::T_DOUBLE, 20);
  xfer += oprot->writeDouble(this->heading);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pitch", ::apache::thrift::protocol::T_DOUBLE, 21);
  xfer += oprot->writeDouble(this->pitch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("roll", ::apache::thrift::protocol::T_DOUBLE, 22);
  xfer += oprot->writeDouble(this->roll);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pose_x", ::apache::thrift::protocol::T_DOUBLE, 23);
  xfer += oprot->writeDouble(this->pose_x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pose_y", ::apache::thrift::protocol::T_DOUBLE, 24);
  xfer += oprot->writeDouble(this->pose_y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Localize &a, Localize &b) {
  using ::std::swap;
  swap(a.timestamp, b.timestamp);
  swap(a.raw_data, b.raw_data);
  swap(a.mTime, b.mTime);
  swap(a.latitude, b.latitude);
  swap(a.longitude, b.longitude);
  swap(a.altitude, b.altitude);
  swap(a.vel_x, b.vel_x);
  swap(a.vel_y, b.vel_y);
  swap(a.vel_z, b.vel_z);
  swap(a.acc_x, b.acc_x);
  swap(a.acc_y, b.acc_y);
  swap(a.acc_z, b.acc_z);
  swap(a.nav_mode, b.nav_mode);
  swap(a.pos_mode, b.pos_mode);
  swap(a.vel_mode, b.vel_mode);
  swap(a.att_mode, b.att_mode);
  swap(a.angular_vel_x, b.angular_vel_x);
  swap(a.angular_vel_y, b.angular_vel_y);
  swap(a.angular_vel_z, b.angular_vel_z);
  swap(a.heading, b.heading);
  swap(a.pitch, b.pitch);
  swap(a.roll, b.roll);
  swap(a.pose_x, b.pose_x);
  swap(a.pose_y, b.pose_y);
  swap(a.__isset, b.__isset);
}

Localize::Localize(const Localize& other44) {
  timestamp = other44.timestamp;
  raw_data = other44.raw_data;
  mTime = other44.mTime;
  latitude = other44.latitude;
  longitude = other44.longitude;
  altitude = other44.altitude;
  vel_x = other44.vel_x;
  vel_y = other44.vel_y;
  vel_z = other44.vel_z;
  acc_x = other44.acc_x;
  acc_y = other44.acc_y;
  acc_z = other44.acc_z;
  nav_mode = other44.nav_mode;
  pos_mode = other44.pos_mode;
  vel_mode = other44.vel_mode;
  att_mode = other44.att_mode;
  angular_vel_x = other44.angular_vel_x;
  angular_vel_y = other44.angular_vel_y;
  angular_vel_z = other44.angular_vel_z;
  heading = other44.heading;
  pitch = other44.pitch;
  roll = other44.roll;
  pose_x = other44.pose_x;
  pose_y = other44.pose_y;
  __isset = other44.__isset;
}
Localize& Localize::operator=(const Localize& other45) {
  timestamp = other45.timestamp;
  raw_data = other45.raw_data;
  mTime = other45.mTime;
  latitude = other45.latitude;
  longitude = other45.longitude;
  altitude = other45.altitude;
  vel_x = other45.vel_x;
  vel_y = other45.vel_y;
  vel_z = other45.vel_z;
  acc_x = other45.acc_x;
  acc_y = other45.acc_y;
  acc_z = other45.acc_z;
  nav_mode = other45.nav_mode;
  pos_mode = other45.pos_mode;
  vel_mode = other45.vel_mode;
  att_mode = other45.att_mode;
  angular_vel_x = other45.angular_vel_x;
  angular_vel_y = other45.angular_vel_y;
  angular_vel_z = other45.angular_vel_z;
  heading = other45.heading;
  pitch = other45.pitch;
  roll = other45.roll;
  pose_x = other45.pose_x;
  pose_y = other45.pose_y;
  __isset = other45.__isset;
  return *this;
}
void Localize::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Localize(";
  out << "timestamp=" << to_string(timestamp);
  out << ", " << "raw_data=" << to_string(raw_data);
  out << ", " << "mTime=" << to_string(mTime);
  out << ", " << "latitude=" << to_string(latitude);
  out << ", " << "longitude=" << to_string(longitude);
  out << ", " << "altitude=" << to_string(altitude);
  out << ", " << "vel_x=" << to_string(vel_x);
  out << ", " << "vel_y=" << to_string(vel_y);
  out << ", " << "vel_z=" << to_string(vel_z);
  out << ", " << "acc_x=" << to_string(acc_x);
  out << ", " << "acc_y=" << to_string(acc_y);
  out << ", " << "acc_z=" << to_string(acc_z);
  out << ", " << "nav_mode=" << to_string(nav_mode);
  out << ", " << "pos_mode=" << to_string(pos_mode);
  out << ", " << "vel_mode=" << to_string(vel_mode);
  out << ", " << "att_mode=" << to_string(att_mode);
  out << ", " << "angular_vel_x=" << to_string(angular_vel_x);
  out << ", " << "angular_vel_y=" << to_string(angular_vel_y);
  out << ", " << "angular_vel_z=" << to_string(angular_vel_z);
  out << ", " << "heading=" << to_string(heading);
  out << ", " << "pitch=" << to_string(pitch);
  out << ", " << "roll=" << to_string(roll);
  out << ", " << "pose_x=" << to_string(pose_x);
  out << ", " << "pose_y=" << to_string(pose_y);
  out << ")";
}


Dest::~Dest() throw() {
}


void Dest::__set_timestamp(const int64_t val) {
  this->timestamp = val;
}

void Dest::__set_x(const double val) {
  this->x = val;
}

void Dest::__set_y(const double val) {
  this->y = val;
}

void Dest::__set_z(const double val) {
  this->z = val;
}

uint32_t Dest::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->z);
          this->__isset.z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Dest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Dest");

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("z", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Dest &a, Dest &b) {
  using ::std::swap;
  swap(a.timestamp, b.timestamp);
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.z, b.z);
  swap(a.__isset, b.__isset);
}

Dest::Dest(const Dest& other46) {
  timestamp = other46.timestamp;
  x = other46.x;
  y = other46.y;
  z = other46.z;
  __isset = other46.__isset;
}
Dest& Dest::operator=(const Dest& other47) {
  timestamp = other47.timestamp;
  x = other47.x;
  y = other47.y;
  z = other47.z;
  __isset = other47.__isset;
  return *this;
}
void Dest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Dest(";
  out << "timestamp=" << to_string(timestamp);
  out << ", " << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ", " << "z=" << to_string(z);
  out << ")";
}


Pose::~Pose() throw() {
}


void Pose::__set_timestamp(const int64_t val) {
  this->timestamp = val;
}

void Pose::__set_x(const double val) {
  this->x = val;
}

void Pose::__set_y(const double val) {
  this->y = val;
}

void Pose::__set_theta(const double val) {
  this->theta = val;
}

void Pose::__set_curvature(const double val) {
  this->curvature = val;
}

void Pose::__set_velocity(const double val) {
  this->velocity = val;
}

void Pose::__set_acceleration(const double val) {
  this->acceleration = val;
}

uint32_t Pose::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->theta);
          this->__isset.theta = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->curvature);
          this->__isset.curvature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->velocity);
          this->__isset.velocity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->acceleration);
          this->__isset.acceleration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Pose::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Pose");

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("theta", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->theta);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("curvature", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->curvature);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("velocity", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->velocity);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("acceleration", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->acceleration);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Pose &a, Pose &b) {
  using ::std::swap;
  swap(a.timestamp, b.timestamp);
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.theta, b.theta);
  swap(a.curvature, b.curvature);
  swap(a.velocity, b.velocity);
  swap(a.acceleration, b.acceleration);
  swap(a.__isset, b.__isset);
}

Pose::Pose(const Pose& other48) {
  timestamp = other48.timestamp;
  x = other48.x;
  y = other48.y;
  theta = other48.theta;
  curvature = other48.curvature;
  velocity = other48.velocity;
  acceleration = other48.acceleration;
  __isset = other48.__isset;
}
Pose& Pose::operator=(const Pose& other49) {
  timestamp = other49.timestamp;
  x = other49.x;
  y = other49.y;
  theta = other49.theta;
  curvature = other49.curvature;
  velocity = other49.velocity;
  acceleration = other49.acceleration;
  __isset = other49.__isset;
  return *this;
}
void Pose::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Pose(";
  out << "timestamp=" << to_string(timestamp);
  out << ", " << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ", " << "theta=" << to_string(theta);
  out << ", " << "curvature=" << to_string(curvature);
  out << ", " << "velocity=" << to_string(velocity);
  out << ", " << "acceleration=" << to_string(acceleration);
  out << ")";
}


Trajectory::~Trajectory() throw() {
}


void Trajectory::__set_initial_pose(const Pose& val) {
  this->initial_pose = val;
}

void Trajectory::__set_poses(const std::vector<Pose> & val) {
  this->poses = val;
}

void Trajectory::__set_driving_direction(const int16_t val) {
  this->driving_direction = val;
}

void Trajectory::__set_driving_state(const int16_t val) {
  this->driving_state = val;
}

uint32_t Trajectory::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->initial_pose.read(iprot);
          this->__isset.initial_pose = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->poses.clear();
            uint32_t _size50;
            ::apache::thrift::protocol::TType _etype53;
            xfer += iprot->readListBegin(_etype53, _size50);
            this->poses.resize(_size50);
            uint32_t _i54;
            for (_i54 = 0; _i54 < _size50; ++_i54)
            {
              xfer += this->poses[_i54].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.poses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->driving_direction);
          this->__isset.driving_direction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->driving_state);
          this->__isset.driving_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Trajectory::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Trajectory");

  xfer += oprot->writeFieldBegin("initial_pose", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->initial_pose.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("poses", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->poses.size()));
    std::vector<Pose> ::const_iterator _iter55;
    for (_iter55 = this->poses.begin(); _iter55 != this->poses.end(); ++_iter55)
    {
      xfer += (*_iter55).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("driving_direction", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->driving_direction);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("driving_state", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->driving_state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Trajectory &a, Trajectory &b) {
  using ::std::swap;
  swap(a.initial_pose, b.initial_pose);
  swap(a.poses, b.poses);
  swap(a.driving_direction, b.driving_direction);
  swap(a.driving_state, b.driving_state);
  swap(a.__isset, b.__isset);
}

Trajectory::Trajectory(const Trajectory& other56) {
  initial_pose = other56.initial_pose;
  poses = other56.poses;
  driving_direction = other56.driving_direction;
  driving_state = other56.driving_state;
  __isset = other56.__isset;
}
Trajectory& Trajectory::operator=(const Trajectory& other57) {
  initial_pose = other57.initial_pose;
  poses = other57.poses;
  driving_direction = other57.driving_direction;
  driving_state = other57.driving_state;
  __isset = other57.__isset;
  return *this;
}
void Trajectory::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Trajectory(";
  out << "initial_pose=" << to_string(initial_pose);
  out << ", " << "poses=" << to_string(poses);
  out << ", " << "driving_direction=" << to_string(driving_direction);
  out << ", " << "driving_state=" << to_string(driving_state);
  out << ")";
}


Fusionmap::~Fusionmap() throw() {
}


void Fusionmap::__set_timestamp(const int64_t val) {
  this->timestamp = val;
}

void Fusionmap::__set_dynamic_object_list(const std::vector<DynamicObstacle> & val) {
  this->dynamic_object_list = val;
}

void Fusionmap::__set_obstacle_map(const GridMap& val) {
  this->obstacle_map = val;
}

void Fusionmap::__set_section_list(const std::vector<SectionList> & val) {
  this->section_list = val;
}

void Fusionmap::__set_pose(const Pose& val) {
  this->pose = val;
}

uint32_t Fusionmap::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dynamic_object_list.clear();
            uint32_t _size58;
            ::apache::thrift::protocol::TType _etype61;
            xfer += iprot->readListBegin(_etype61, _size58);
            this->dynamic_object_list.resize(_size58);
            uint32_t _i62;
            for (_i62 = 0; _i62 < _size58; ++_i62)
            {
              xfer += this->dynamic_object_list[_i62].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dynamic_object_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->obstacle_map.read(iprot);
          this->__isset.obstacle_map = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->section_list.clear();
            uint32_t _size63;
            ::apache::thrift::protocol::TType _etype66;
            xfer += iprot->readListBegin(_etype66, _size63);
            this->section_list.resize(_size63);
            uint32_t _i67;
            for (_i67 = 0; _i67 < _size63; ++_i67)
            {
              xfer += this->section_list[_i67].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.section_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pose.read(iprot);
          this->__isset.pose = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Fusionmap::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Fusionmap");

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dynamic_object_list", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dynamic_object_list.size()));
    std::vector<DynamicObstacle> ::const_iterator _iter68;
    for (_iter68 = this->dynamic_object_list.begin(); _iter68 != this->dynamic_object_list.end(); ++_iter68)
    {
      xfer += (*_iter68).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("obstacle_map", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->obstacle_map.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("section_list", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->section_list.size()));
    std::vector<SectionList> ::const_iterator _iter69;
    for (_iter69 = this->section_list.begin(); _iter69 != this->section_list.end(); ++_iter69)
    {
      xfer += (*_iter69).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pose", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->pose.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Fusionmap &a, Fusionmap &b) {
  using ::std::swap;
  swap(a.timestamp, b.timestamp);
  swap(a.dynamic_object_list, b.dynamic_object_list);
  swap(a.obstacle_map, b.obstacle_map);
  swap(a.section_list, b.section_list);
  swap(a.pose, b.pose);
  swap(a.__isset, b.__isset);
}

Fusionmap::Fusionmap(const Fusionmap& other70) {
  timestamp = other70.timestamp;
  dynamic_object_list = other70.dynamic_object_list;
  obstacle_map = other70.obstacle_map;
  section_list = other70.section_list;
  pose = other70.pose;
  __isset = other70.__isset;
}
Fusionmap& Fusionmap::operator=(const Fusionmap& other71) {
  timestamp = other71.timestamp;
  dynamic_object_list = other71.dynamic_object_list;
  obstacle_map = other71.obstacle_map;
  section_list = other71.section_list;
  pose = other71.pose;
  __isset = other71.__isset;
  return *this;
}
void Fusionmap::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Fusionmap(";
  out << "timestamp=" << to_string(timestamp);
  out << ", " << "dynamic_object_list=" << to_string(dynamic_object_list);
  out << ", " << "obstacle_map=" << to_string(obstacle_map);
  out << ", " << "section_list=" << to_string(section_list);
  out << ", " << "pose=" << to_string(pose);
  out << ")";
}

} // namespace
