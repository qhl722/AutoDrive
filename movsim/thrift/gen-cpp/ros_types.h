/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef ros_TYPES_H
#define ros_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace Ros {

class GridMap;

class WayPoint;

class LaneMarker;

class SectionList;

class DynamicObstacle;

class TrafficLight;

class TrafficLightDetect;

class Localize;

class Dest;

class Pose;

class Trajectory;

class Fusionmap;

typedef struct _GridMap__isset {
  _GridMap__isset() : width(false), length(false), center_x(false), center_y(false), grid_map(false) {}
  bool width :1;
  bool length :1;
  bool center_x :1;
  bool center_y :1;
  bool grid_map :1;
} _GridMap__isset;

class GridMap {
 public:

  GridMap(const GridMap&);
  GridMap& operator=(const GridMap&);
  GridMap() : width(0), length(0), center_x(0), center_y(0) {
  }

  virtual ~GridMap() throw();
  int32_t width;
  int32_t length;
  int32_t center_x;
  int32_t center_y;
  std::vector<int16_t>  grid_map;

  _GridMap__isset __isset;

  void __set_width(const int32_t val);

  void __set_length(const int32_t val);

  void __set_center_x(const int32_t val);

  void __set_center_y(const int32_t val);

  void __set_grid_map(const std::vector<int16_t> & val);

  bool operator == (const GridMap & rhs) const
  {
    if (!(width == rhs.width))
      return false;
    if (!(length == rhs.length))
      return false;
    if (!(center_x == rhs.center_x))
      return false;
    if (!(center_y == rhs.center_y))
      return false;
    if (!(grid_map == rhs.grid_map))
      return false;
    return true;
  }
  bool operator != (const GridMap &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GridMap & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GridMap &a, GridMap &b);

inline std::ostream& operator<<(std::ostream& out, const GridMap& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _WayPoint__isset {
  _WayPoint__isset() : x(false), y(false) {}
  bool x :1;
  bool y :1;
} _WayPoint__isset;

class WayPoint {
 public:

  WayPoint(const WayPoint&);
  WayPoint& operator=(const WayPoint&);
  WayPoint() : x(0), y(0) {
  }

  virtual ~WayPoint() throw();
  double x;
  double y;

  _WayPoint__isset __isset;

  void __set_x(const double val);

  void __set_y(const double val);

  bool operator == (const WayPoint & rhs) const
  {
    if (!(x == rhs.x))
      return false;
    if (!(y == rhs.y))
      return false;
    return true;
  }
  bool operator != (const WayPoint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const WayPoint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(WayPoint &a, WayPoint &b);

inline std::ostream& operator<<(std::ostream& out, const WayPoint& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _LaneMarker__isset {
  _LaneMarker__isset() : paint_type(false), waypoints(false) {}
  bool paint_type :1;
  bool waypoints :1;
} _LaneMarker__isset;

class LaneMarker {
 public:

  LaneMarker(const LaneMarker&);
  LaneMarker& operator=(const LaneMarker&);
  LaneMarker() : paint_type(0) {
  }

  virtual ~LaneMarker() throw();
  int16_t paint_type;
  std::vector<WayPoint>  waypoints;

  _LaneMarker__isset __isset;

  void __set_paint_type(const int16_t val);

  void __set_waypoints(const std::vector<WayPoint> & val);

  bool operator == (const LaneMarker & rhs) const
  {
    if (!(paint_type == rhs.paint_type))
      return false;
    if (!(waypoints == rhs.waypoints))
      return false;
    return true;
  }
  bool operator != (const LaneMarker &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LaneMarker & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LaneMarker &a, LaneMarker &b);

inline std::ostream& operator<<(std::ostream& out, const LaneMarker& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SectionList__isset {
  _SectionList__isset() : lane_marker_list(false), section_type(false) {}
  bool lane_marker_list :1;
  bool section_type :1;
} _SectionList__isset;

class SectionList {
 public:

  SectionList(const SectionList&);
  SectionList& operator=(const SectionList&);
  SectionList() : section_type(0) {
  }

  virtual ~SectionList() throw();
  std::vector<LaneMarker>  lane_marker_list;
  int16_t section_type;

  _SectionList__isset __isset;

  void __set_lane_marker_list(const std::vector<LaneMarker> & val);

  void __set_section_type(const int16_t val);

  bool operator == (const SectionList & rhs) const
  {
    if (!(lane_marker_list == rhs.lane_marker_list))
      return false;
    if (!(section_type == rhs.section_type))
      return false;
    return true;
  }
  bool operator != (const SectionList &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SectionList & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SectionList &a, SectionList &b);

inline std::ostream& operator<<(std::ostream& out, const SectionList& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DynamicObstacle__isset {
  _DynamicObstacle__isset() : class_id(false), id(false), center_x(false), center_y(false), center_z(false), width(false), height(false), length(false), velocity(false), heading(false), omega(false), acceleration(false), shield_time(false), velocity_measurement_covariance(false) {}
  bool class_id :1;
  bool id :1;
  bool center_x :1;
  bool center_y :1;
  bool center_z :1;
  bool width :1;
  bool height :1;
  bool length :1;
  bool velocity :1;
  bool heading :1;
  bool omega :1;
  bool acceleration :1;
  bool shield_time :1;
  bool velocity_measurement_covariance :1;
} _DynamicObstacle__isset;

class DynamicObstacle {
 public:

  DynamicObstacle(const DynamicObstacle&);
  DynamicObstacle& operator=(const DynamicObstacle&);
  DynamicObstacle() : class_id(0), id(0), center_x(0), center_y(0), center_z(0), width(0), height(0), length(0), velocity(0), heading(0), omega(0), acceleration(0), shield_time(0) {
  }

  virtual ~DynamicObstacle() throw();
  int16_t class_id;
  int64_t id;
  double center_x;
  double center_y;
  double center_z;
  double width;
  double height;
  double length;
  double velocity;
  double heading;
  double omega;
  double acceleration;
  double shield_time;
  std::vector<double>  velocity_measurement_covariance;

  _DynamicObstacle__isset __isset;

  void __set_class_id(const int16_t val);

  void __set_id(const int64_t val);

  void __set_center_x(const double val);

  void __set_center_y(const double val);

  void __set_center_z(const double val);

  void __set_width(const double val);

  void __set_height(const double val);

  void __set_length(const double val);

  void __set_velocity(const double val);

  void __set_heading(const double val);

  void __set_omega(const double val);

  void __set_acceleration(const double val);

  void __set_shield_time(const double val);

  void __set_velocity_measurement_covariance(const std::vector<double> & val);

  bool operator == (const DynamicObstacle & rhs) const
  {
    if (!(class_id == rhs.class_id))
      return false;
    if (!(id == rhs.id))
      return false;
    if (!(center_x == rhs.center_x))
      return false;
    if (!(center_y == rhs.center_y))
      return false;
    if (!(center_z == rhs.center_z))
      return false;
    if (!(width == rhs.width))
      return false;
    if (!(height == rhs.height))
      return false;
    if (!(length == rhs.length))
      return false;
    if (!(velocity == rhs.velocity))
      return false;
    if (!(heading == rhs.heading))
      return false;
    if (!(omega == rhs.omega))
      return false;
    if (!(acceleration == rhs.acceleration))
      return false;
    if (!(shield_time == rhs.shield_time))
      return false;
    if (!(velocity_measurement_covariance == rhs.velocity_measurement_covariance))
      return false;
    return true;
  }
  bool operator != (const DynamicObstacle &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DynamicObstacle & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DynamicObstacle &a, DynamicObstacle &b);

inline std::ostream& operator<<(std::ostream& out, const DynamicObstacle& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TrafficLight__isset {
  _TrafficLight__isset() : id(false), type(false), status(false), time(false), confidence(false) {}
  bool id :1;
  bool type :1;
  bool status :1;
  bool time :1;
  bool confidence :1;
} _TrafficLight__isset;

class TrafficLight {
 public:

  TrafficLight(const TrafficLight&);
  TrafficLight& operator=(const TrafficLight&);
  TrafficLight() : id(0), type(0), status(0), time(0), confidence(0) {
  }

  virtual ~TrafficLight() throw();
  int16_t id;
  int16_t type;
  int16_t status;
  int16_t time;
  double confidence;

  _TrafficLight__isset __isset;

  void __set_id(const int16_t val);

  void __set_type(const int16_t val);

  void __set_status(const int16_t val);

  void __set_time(const int16_t val);

  void __set_confidence(const double val);

  bool operator == (const TrafficLight & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(time == rhs.time))
      return false;
    if (!(confidence == rhs.confidence))
      return false;
    return true;
  }
  bool operator != (const TrafficLight &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TrafficLight & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TrafficLight &a, TrafficLight &b);

inline std::ostream& operator<<(std::ostream& out, const TrafficLight& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TrafficLightDetect__isset {
  _TrafficLightDetect__isset() : timestamp(false), tl_det_list(false) {}
  bool timestamp :1;
  bool tl_det_list :1;
} _TrafficLightDetect__isset;

class TrafficLightDetect {
 public:

  TrafficLightDetect(const TrafficLightDetect&);
  TrafficLightDetect& operator=(const TrafficLightDetect&);
  TrafficLightDetect() : timestamp(0) {
  }

  virtual ~TrafficLightDetect() throw();
  int64_t timestamp;
  std::vector<TrafficLight>  tl_det_list;

  _TrafficLightDetect__isset __isset;

  void __set_timestamp(const int64_t val);

  void __set_tl_det_list(const std::vector<TrafficLight> & val);

  bool operator == (const TrafficLightDetect & rhs) const
  {
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(tl_det_list == rhs.tl_det_list))
      return false;
    return true;
  }
  bool operator != (const TrafficLightDetect &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TrafficLightDetect & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TrafficLightDetect &a, TrafficLightDetect &b);

inline std::ostream& operator<<(std::ostream& out, const TrafficLightDetect& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Localize__isset {
  _Localize__isset() : timestamp(false), raw_data(false), mTime(false), latitude(false), longitude(false), altitude(false), vel_x(false), vel_y(false), vel_z(false), acc_x(false), acc_y(false), acc_z(false), nav_mode(false), pos_mode(false), vel_mode(false), att_mode(false), angular_vel_x(false), angular_vel_y(false), angular_vel_z(false), heading(false), pitch(false), roll(false), pose_x(false), pose_y(false) {}
  bool timestamp :1;
  bool raw_data :1;
  bool mTime :1;
  bool latitude :1;
  bool longitude :1;
  bool altitude :1;
  bool vel_x :1;
  bool vel_y :1;
  bool vel_z :1;
  bool acc_x :1;
  bool acc_y :1;
  bool acc_z :1;
  bool nav_mode :1;
  bool pos_mode :1;
  bool vel_mode :1;
  bool att_mode :1;
  bool angular_vel_x :1;
  bool angular_vel_y :1;
  bool angular_vel_z :1;
  bool heading :1;
  bool pitch :1;
  bool roll :1;
  bool pose_x :1;
  bool pose_y :1;
} _Localize__isset;

class Localize {
 public:

  Localize(const Localize&);
  Localize& operator=(const Localize&);
  Localize() : timestamp(0), raw_data(), mTime(0), latitude(0), longitude(0), altitude(0), vel_x(0), vel_y(0), vel_z(0), acc_x(0), acc_y(0), acc_z(0), nav_mode(0), pos_mode(0), vel_mode(0), att_mode(0), angular_vel_x(0), angular_vel_y(0), angular_vel_z(0), heading(0), pitch(0), roll(0), pose_x(0), pose_y(0) {
  }

  virtual ~Localize() throw();
  int64_t timestamp;
  std::string raw_data;
  double mTime;
  double latitude;
  double longitude;
  double altitude;
  double vel_x;
  double vel_y;
  double vel_z;
  double acc_x;
  double acc_y;
  double acc_z;
  int16_t nav_mode;
  int16_t pos_mode;
  int16_t vel_mode;
  int16_t att_mode;
  double angular_vel_x;
  double angular_vel_y;
  double angular_vel_z;
  double heading;
  double pitch;
  double roll;
  double pose_x;
  double pose_y;

  _Localize__isset __isset;

  void __set_timestamp(const int64_t val);

  void __set_raw_data(const std::string& val);

  void __set_mTime(const double val);

  void __set_latitude(const double val);

  void __set_longitude(const double val);

  void __set_altitude(const double val);

  void __set_vel_x(const double val);

  void __set_vel_y(const double val);

  void __set_vel_z(const double val);

  void __set_acc_x(const double val);

  void __set_acc_y(const double val);

  void __set_acc_z(const double val);

  void __set_nav_mode(const int16_t val);

  void __set_pos_mode(const int16_t val);

  void __set_vel_mode(const int16_t val);

  void __set_att_mode(const int16_t val);

  void __set_angular_vel_x(const double val);

  void __set_angular_vel_y(const double val);

  void __set_angular_vel_z(const double val);

  void __set_heading(const double val);

  void __set_pitch(const double val);

  void __set_roll(const double val);

  void __set_pose_x(const double val);

  void __set_pose_y(const double val);

  bool operator == (const Localize & rhs) const
  {
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(raw_data == rhs.raw_data))
      return false;
    if (!(mTime == rhs.mTime))
      return false;
    if (!(latitude == rhs.latitude))
      return false;
    if (!(longitude == rhs.longitude))
      return false;
    if (!(altitude == rhs.altitude))
      return false;
    if (!(vel_x == rhs.vel_x))
      return false;
    if (!(vel_y == rhs.vel_y))
      return false;
    if (!(vel_z == rhs.vel_z))
      return false;
    if (!(acc_x == rhs.acc_x))
      return false;
    if (!(acc_y == rhs.acc_y))
      return false;
    if (!(acc_z == rhs.acc_z))
      return false;
    if (!(nav_mode == rhs.nav_mode))
      return false;
    if (!(pos_mode == rhs.pos_mode))
      return false;
    if (!(vel_mode == rhs.vel_mode))
      return false;
    if (!(att_mode == rhs.att_mode))
      return false;
    if (!(angular_vel_x == rhs.angular_vel_x))
      return false;
    if (!(angular_vel_y == rhs.angular_vel_y))
      return false;
    if (!(angular_vel_z == rhs.angular_vel_z))
      return false;
    if (!(heading == rhs.heading))
      return false;
    if (!(pitch == rhs.pitch))
      return false;
    if (!(roll == rhs.roll))
      return false;
    if (!(pose_x == rhs.pose_x))
      return false;
    if (!(pose_y == rhs.pose_y))
      return false;
    return true;
  }
  bool operator != (const Localize &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Localize & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Localize &a, Localize &b);

inline std::ostream& operator<<(std::ostream& out, const Localize& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Dest__isset {
  _Dest__isset() : timestamp(false), x(false), y(false), z(false) {}
  bool timestamp :1;
  bool x :1;
  bool y :1;
  bool z :1;
} _Dest__isset;

class Dest {
 public:

  Dest(const Dest&);
  Dest& operator=(const Dest&);
  Dest() : timestamp(0), x(0), y(0), z(0) {
  }

  virtual ~Dest() throw();
  int64_t timestamp;
  double x;
  double y;
  double z;

  _Dest__isset __isset;

  void __set_timestamp(const int64_t val);

  void __set_x(const double val);

  void __set_y(const double val);

  void __set_z(const double val);

  bool operator == (const Dest & rhs) const
  {
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(x == rhs.x))
      return false;
    if (!(y == rhs.y))
      return false;
    if (!(z == rhs.z))
      return false;
    return true;
  }
  bool operator != (const Dest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Dest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Dest &a, Dest &b);

inline std::ostream& operator<<(std::ostream& out, const Dest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Pose__isset {
  _Pose__isset() : timestamp(false), x(false), y(false), theta(false), curvature(false), velocity(false), acceleration(false) {}
  bool timestamp :1;
  bool x :1;
  bool y :1;
  bool theta :1;
  bool curvature :1;
  bool velocity :1;
  bool acceleration :1;
} _Pose__isset;

class Pose {
 public:

  Pose(const Pose&);
  Pose& operator=(const Pose&);
  Pose() : timestamp(0), x(0), y(0), theta(0), curvature(0), velocity(0), acceleration(0) {
  }

  virtual ~Pose() throw();
  int64_t timestamp;
  double x;
  double y;
  double theta;
  double curvature;
  double velocity;
  double acceleration;

  _Pose__isset __isset;

  void __set_timestamp(const int64_t val);

  void __set_x(const double val);

  void __set_y(const double val);

  void __set_theta(const double val);

  void __set_curvature(const double val);

  void __set_velocity(const double val);

  void __set_acceleration(const double val);

  bool operator == (const Pose & rhs) const
  {
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(x == rhs.x))
      return false;
    if (!(y == rhs.y))
      return false;
    if (!(theta == rhs.theta))
      return false;
    if (!(curvature == rhs.curvature))
      return false;
    if (!(velocity == rhs.velocity))
      return false;
    if (!(acceleration == rhs.acceleration))
      return false;
    return true;
  }
  bool operator != (const Pose &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Pose & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Pose &a, Pose &b);

inline std::ostream& operator<<(std::ostream& out, const Pose& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Trajectory__isset {
  _Trajectory__isset() : initial_pose(false), poses(false), driving_direction(false), driving_state(false) {}
  bool initial_pose :1;
  bool poses :1;
  bool driving_direction :1;
  bool driving_state :1;
} _Trajectory__isset;

class Trajectory {
 public:

  Trajectory(const Trajectory&);
  Trajectory& operator=(const Trajectory&);
  Trajectory() : driving_direction(0), driving_state(0) {
  }

  virtual ~Trajectory() throw();
  Pose initial_pose;
  std::vector<Pose>  poses;
  int16_t driving_direction;
  int16_t driving_state;

  _Trajectory__isset __isset;

  void __set_initial_pose(const Pose& val);

  void __set_poses(const std::vector<Pose> & val);

  void __set_driving_direction(const int16_t val);

  void __set_driving_state(const int16_t val);

  bool operator == (const Trajectory & rhs) const
  {
    if (!(initial_pose == rhs.initial_pose))
      return false;
    if (!(poses == rhs.poses))
      return false;
    if (!(driving_direction == rhs.driving_direction))
      return false;
    if (!(driving_state == rhs.driving_state))
      return false;
    return true;
  }
  bool operator != (const Trajectory &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Trajectory & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Trajectory &a, Trajectory &b);

inline std::ostream& operator<<(std::ostream& out, const Trajectory& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Fusionmap__isset {
  _Fusionmap__isset() : timestamp(false), dynamic_object_list(false), obstacle_map(false), section_list(false), pose(false) {}
  bool timestamp :1;
  bool dynamic_object_list :1;
  bool obstacle_map :1;
  bool section_list :1;
  bool pose :1;
} _Fusionmap__isset;

class Fusionmap {
 public:

  Fusionmap(const Fusionmap&);
  Fusionmap& operator=(const Fusionmap&);
  Fusionmap() : timestamp(0) {
  }

  virtual ~Fusionmap() throw();
  int64_t timestamp;
  std::vector<DynamicObstacle>  dynamic_object_list;
  GridMap obstacle_map;
  std::vector<SectionList>  section_list;
  Pose pose;

  _Fusionmap__isset __isset;

  void __set_timestamp(const int64_t val);

  void __set_dynamic_object_list(const std::vector<DynamicObstacle> & val);

  void __set_obstacle_map(const GridMap& val);

  void __set_section_list(const std::vector<SectionList> & val);

  void __set_pose(const Pose& val);

  bool operator == (const Fusionmap & rhs) const
  {
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(dynamic_object_list == rhs.dynamic_object_list))
      return false;
    if (!(obstacle_map == rhs.obstacle_map))
      return false;
    if (!(section_list == rhs.section_list))
      return false;
    if (!(pose == rhs.pose))
      return false;
    return true;
  }
  bool operator != (const Fusionmap &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Fusionmap & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Fusionmap &a, Fusionmap &b);

inline std::ostream& operator<<(std::ostream& out, const Fusionmap& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#endif
