// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "RosService.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

#include <unistd.h>

#include <ros/ros.h>
#include <av_comm/comm.h>
#include <av_msgs/FusionMap.h>
#include <av_msgs/TrafficLightDetect.h>
#include <av_msgs/Trajectory.h>
#include <av_msgs/Dest.h>
#include <av_msgs/Localize.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::Ros;

class RosServiceHandler : virtual public RosServiceIf {
 public:
  RosServiceHandler()
    :fusion_map_queue_size_(10),
    dest_queue_size_(10),
    traffic_light_queue_size_(10),
    localize_queue_size_(10) {
    // Your initialization goes here
    pub_fusion_map = nh.advertise<av_msgs::FusionMap>("/av_perception/sensor_fusion/fusion_map", fusion_map_queue_size_);
    pub_traffic_light_detect = nh.advertise<av_msgs::TrafficLightDetect>("/av_perception/localization/traffic_light_perception/traffic_light_detect", traffic_light_queue_size_);
    pub_localize = nh.advertise<av_msgs::Localize>("/av_localization/localization/localize", localize_queue_size_);
    pub_dest = nh.advertise<av_msgs::Dest>("/av_localization/localization/dest", dest_queue_size_);
    sub_trajectory = nh.subscribe("/av_planning/planning/trajectory", 10, &RosServiceHandler::subscribeTrajectoryCallback, this);

    ROS_INFO("Movsim Publisher Started...");
  }

  void getTrajectory(Trajectory& _return) {
    if (ros::ok() && isGot) {
      _return = convertTrajectory(trajectory_);
      ROS_INFO("New Trajectory Got...");
      isGot = false;
    }
    return;
  }

  void publishFusionMap(const Fusionmap& fusion_map) {
    ROS_INFO("Get fusion map...");
    if (ros::ok()) {
      av_msgs::FusionMap fusion_map_ = convertFusionmap(fusion_map);
      pub_fusion_map.publish(fusion_map_);
      ROS_INFO("Fusion Map Published...");
    }
  }

  void publishTrafficLightDetect(const TrafficLightDetect& traffic_light_detect) {
    if (ros::ok()) {
      av_msgs::TrafficLightDetect trafficLightDetect_ = convertTrafficLightDetect(traffic_light_detect);
      pub_traffic_light_detect.publish(trafficLightDetect_);
      ROS_INFO("TrafficLightDetect published...");
    }
  }

  void publishLocalize(const Localize& localize) {
    if (ros::ok()) {
      av_msgs::Localize localize_ = convertLocalize(localize);
      pub_localize.publish(localize_);
      ROS_INFO("Localize Published...");
    }
  }

  void publishDest(const Dest& dest) {
    if (ros::ok()) {
      av_msgs::Dest dest_ = convertDest(dest);
      pub_dest.publish(dest_);
      ROS_INFO("Dest Published...");
    }
  }

 private:
  ros::NodeHandle nh;
  ros::Publisher pub_fusion_map;
  ros::Publisher pub_dest;
  ros::Publisher pub_traffic_light_detect;
  ros::Publisher pub_localize;
  ros::Subscriber sub_trajectory;
  int fusion_map_queue_size_;
  int dest_queue_size_;
  int traffic_light_queue_size_;
  int localize_queue_size_;
  av_msgs::Trajectory trajectory_;
  bool isGot;

  void subscribeTrajectoryCallback(const av_msgs::Trajectory trajectory) {
    trajectory_ = trajectory;
    isGot = true;
  }

  av_msgs::GridMap convertGridMap(GridMap grid_map) {
    av_msgs::GridMap gridMap;
    gridMap.width = grid_map.width;
    gridMap.length = grid_map.length;
    gridMap.center_x = grid_map.center_x;
    gridMap.center_y = grid_map.center_y;
    std::vector<uint8_t> v;
    for (auto num : grid_map.grid_map) {
      v.push_back((uint8_t) num);
    }
    gridMap.grid_map = v;

    return gridMap;
  }

  av_msgs::Pose convertPose(Pose pose) {
    av_msgs::Pose av_pose;
    av_pose.timestamp = pose.timestamp;
    av_pose.x = pose.x;
    av_pose.y = pose.y;
    av_pose.theta = pose.theta;
    av_pose.curvature = pose.curvature;
    av_pose.velocity = pose.velocity;
    av_pose.acceleration = pose.acceleration;
    return av_pose;
  }

  av_msgs::WayPoint convertWayPoint(WayPoint way_point) {
    av_msgs::WayPoint wayPoint;
    wayPoint.x = way_point.x;
    wayPoint.y = way_point.y;

    return wayPoint;
  } 

  av_msgs::LaneMarker convertLaneMarker(LaneMarker lane_marker) {
    av_msgs::LaneMarker laneMarker;
    laneMarker.paint_type = (int8_t) lane_marker.paint_type;
    std::vector<av_msgs::WayPoint> v;
    for (auto item : lane_marker.waypoints) {
      v.push_back(convertWayPoint(item));
    }
    laneMarker.waypoints = v;

    return laneMarker;
  }

  av_msgs::SectionList convertSectionList(SectionList section_list) {
    av_msgs::SectionList sectionList;
    sectionList.section_type = (int8_t) section_list.section_type;

    std::vector<av_msgs::LaneMarker> v;
    for (auto item : section_list.lane_marker_list) {
      v.push_back(convertLaneMarker(item));
    }
    sectionList.lane_marker_list = v;

    return sectionList;
  }

  av_msgs::DynamicObstacle convertDynamicObstacle(DynamicObstacle dynamic_obstacle) {
    av_msgs::DynamicObstacle dynamicObstacle;
    dynamicObstacle.class_id = (uint8_t) dynamic_obstacle.class_id;
    dynamicObstacle.id = (uint64_t) dynamic_obstacle.id;
    dynamicObstacle.center_x = (float) dynamic_obstacle.center_x;
    dynamicObstacle.center_y = (float) dynamic_obstacle.center_y;
    dynamicObstacle.center_z = (float) dynamic_obstacle.center_z;
    dynamicObstacle.width = (float) dynamic_obstacle.width;
    dynamicObstacle.height = (float) dynamic_obstacle.height;
    dynamicObstacle.length = (float) dynamic_obstacle.length;
    dynamicObstacle.velocity = (float) dynamic_obstacle.velocity;
    dynamicObstacle.heading = (float) dynamic_obstacle.heading;
    dynamicObstacle.omega = (float) dynamic_obstacle.omega;
    dynamicObstacle.acceleration = (float) dynamic_obstacle.acceleration;
    dynamicObstacle.shield_time = (float) dynamic_obstacle.shield_time;
    dynamicObstacle.velocity_measurement_covariance = dynamic_obstacle.velocity_measurement_covariance;

    return dynamicObstacle;
  }

  av_msgs::FusionMap convertFusionmap(Fusionmap fusion_map) {
    av_msgs::FusionMap fusionMap;
    fusionMap.obstacle_map = convertGridMap(fusion_map.obstacle_map);
    fusionMap.timestamp = fusion_map.timestamp;
    fusionMap.pose = convertPose(fusion_map.pose);

    std::vector<av_msgs::DynamicObstacle> v;
    for (auto item : fusion_map.dynamic_object_list) {
      v.push_back(convertDynamicObstacle(item));
    }

    std::vector<av_msgs::SectionList> v2;
    for (auto item : fusion_map.section_list) {
      v2.push_back(convertSectionList(item));
    }

    fusionMap.section_list = v2;
    fusionMap.dynamic_object_list = v;
    return fusionMap;
  }

  av_msgs::TrafficLightDetect convertTrafficLightDetect(TrafficLightDetect traffic_light_detect) {
    av_msgs::TrafficLightDetect trafficLightDetect;
    trafficLightDetect.timestamp = traffic_light_detect.timestamp;
    return trafficLightDetect;
  }

  av_msgs::Localize convertLocalize(Localize localize) {
    av_msgs::Localize av_localize;
    av_localize.timestamp = localize.timestamp;
    av_localize.pose_x = localize.pose_x;
    av_localize.pose_y = localize.pose_y;
    av_localize.acc_x = localize.acc_x;
    av_localize.acc_y = localize.acc_y;
    av_localize.vel_x = localize.vel_x;
    av_localize.vel_y = localize.vel_y;
    av_localize.heading = localize.heading;

    return av_localize;
  }

  av_msgs::Dest convertDest(Dest dest) {
    av_msgs::Dest av_dest;
    av_dest.timestamp = dest.timestamp;
    av_dest.x = dest.x;
    av_dest.y = dest.y;
    return av_dest;
  }

  Pose convertAvPose(av_msgs::Pose av_pose) {
    Pose pose;
    pose.timestamp = av_pose.timestamp;
    pose.x = av_pose.x;
    pose.y = av_pose.y;
    pose.theta = av_pose.theta;
    pose.curvature = av_pose.curvature;
    pose.velocity = av_pose.velocity;
    pose.acceleration = av_pose.acceleration;

    return pose;
  }

  Trajectory convertTrajectory(av_msgs::Trajectory trajectory) {
    Trajectory trajectory_rpc;
    trajectory_rpc.driving_direction = (int16_t) trajectory.driving_direction;
    trajectory_rpc.driving_state = (int16_t) trajectory.driving_state;
    trajectory_rpc.initial_pose = convertAvPose(trajectory.initial_pose);
    std::vector<Pose> v;
    for (auto item : trajectory.poses) {
      v.push_back(convertAvPose(item));
    }
    trajectory_rpc.poses = v;

    return trajectory_rpc;
  }
};

int main(int argc, char **argv) {
  ros::init(argc, argv, "movsimPublisher");

  int port = 23333;
  shared_ptr<RosServiceHandler> handler(new RosServiceHandler());
  shared_ptr<TProcessor> processor(new RosServiceProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

